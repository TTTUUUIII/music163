package org.netease.music.utils

import org.netease.music.MusicEntity
import org.netease.Context.Companion.FFMPEG_PATH
import org.netease.Context.Companion.OUT_PATH
import java.io.FileOutputStream
import java.nio.file.Path
import java.nio.file.Paths

class AutoGenerator {
    companion object {

        private fun generateFfmpegCommand(musicEntities: List<MusicEntity>, sub: String? = ""): String {
            val commands = StringBuilder()
            for (music in musicEntities) {
                if (music.url == null) continue
                val artists = music.artists.joinToString(",") {
                    it.artistName
                }
                val metadata = if (WIN) {
                    arrayOf(
                        "-metadata title=\"${music.name.replace("\"", "'")}\"",
                        "-metadata artist=\"${artists.replace("\"", "'")}\"",
                        "-metadata album=\"${music.album.albumName.replace("\"", "'")}\"",
                        "-metadata album_artist=\"${music.album.albumName.replace("\"", "'")}\""
                    ).joinToString(" ")
                } else {
                    arrayOf(
                        "-metadata title=\'${music.name}\'",
                        "-metadata artist=\'${artists}\'",
                        "-metadata album=\'${music.album.albumName}\'",
                        "-metadata album_artist=\'${music.album.albumName}\'"
                    ).joinToString(" ")
                }
                val filename = "${music.name}-${artists}"
                    .safePath()
                val command = if (WIN) {
                    "$FFMPEG_PATH -i \"${music.url}\" -i \"${music.album.picUrl}\" $metadata -map 0 -c:a copy -map 1 -c:v mjpeg -id3v2_version 3 \"$filename.${music.type}\"$LB"
                } else {
                    "$FFMPEG_PATH -i '${music.url}' -i '${music.album.picUrl}' $metadata -map 0 -c:a copy -map 1 -c:v mjpeg -id3v2_version 3 '$filename.${music.type}'$LB"
                }
                commands.append(command)
                downloadLyric(
                    Paths.get(OUT_PATH)
                        .apply {
                            sub?.let {
                                resolve(it)
                            }
                        }
                        .resolve("$filename.lrc"),
                    music
                )
            }
            return commands.toString()
        }

        private fun downloadLyric(filePath: Path, music: MusicEntity): Boolean {
            var status = false
            music.lyric?.let { lyric ->
                FileOutputStream(filePath.toFile())
                    .use {
                        it.write(lyric.lyric.encodeToByteArray())
                    }
                status = true
            }
            return status
        }

        fun generateFfmpegScript(musicEntities: List<MusicEntity>, path: Path, sub: String? = null) {
            val win = System.getProperty("os.name").lowercase().contains("windows")
            val scriptPath: Path = if (path.toFile().isDirectory) {
                if (win) {
                    path.resolve("fetch-playlist.bat")
                } else {
                    path.resolve("fetch-playlist.sh")
                }
            } else {
                path
            }
            val script = StringBuilder()
            val downloadCommand = generateFfmpegCommand(musicEntities, sub)
            if (win) {
                script.append("CHCP 65001$LB")
                script.append("@ECHO OFF$LB")
                script.append("CLS$LB")
                script.append("@REM This file is automatically generated and relies on ffmpeg$LB")
                script.append("@REM @see: https://ffmpeg.org/$LB")
                script.append("@REM about: https://github.com/TTTUUUIII$LB$LB")

                sub?.let {
                    script.append("if not exist $sub ($LB")
                    script.append("\tmd \"$sub\"$LB")
                    script.append(")$LB")
                    script.append("cd \"$sub\"$LB$LB")
                }
                script.append(downloadCommand)
                script.append("$LB${LB}PAUSE$LB")
            } else {
                script.append("#!/bin/sh$LB$LB")
                script.append("#This file is automatically generated and relies on ffmpeg$LB")
                script.append("#see: https://ffmpeg.org/$LB")
                script.append("#about: https://github.com/TTTUUUIII$LB$LB")
                sub?.let {
                    script.append("mkdir -p '$sub' && cd '$sub'$LB")
                }
                script.append(downloadCommand)
                script.append("$LB${LB}exit 0$LB")
                scriptPath.toFile().setExecutable(true, false)
            }
            FileOutputStream(scriptPath.toFile())
                .use {
                    it.write(script.toString().encodeToByteArray())
                }
        }
    }
}